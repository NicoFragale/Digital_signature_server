% --- Preambolo consigliato (aggiungi se usi il diagramma/tabella) ---
% \usepackage{booktabs}   % per tabelle pulite
% \usepackage{array}      % colonne p{...}
% \usepackage{msc}        % per il diagramma di sequenza (opzionale)

\section{Flusso della comunicazione: descrizione lineare e schemi}

Questa sezione descrive in modo lineare come client e server instaurano il canale sicuro e come avviene lo scambio dei messaggi applicativi, senza riportare codice. I riferimenti ai ``componenti logici'' (es.\ \emph{ClientHello}, \emph{ServerHello}, \emph{Transcript}, \emph{HKDF}, \emph{AES-GCM}) corrispondono alle parti omonime implementate nel progetto.

\subsection{Obiettivo e precondizioni}
\begin{itemize}
  \item \textbf{Obiettivo:} stabilire un canale autenticato e confidenziale con \emph{Perfect Forward Secrecy} (PFS) tra utente e DSS, per poi inviare/rispondere a richieste applicative (es.\ \texttt{SignDoc}).
  \item \textbf{Precondizioni:} l'utente possiede la \textbf{chiave pubblica Ed25519 del server} (distribuita off-line in fase di registrazione).
\end{itemize}

\subsection{Handshake: negoziazione, autenticazione del server, derivazione di $K$}
\begin{enumerate}
  \item \textbf{Caricamento chiave del server (lato client).} Il client carica la chiave pubblica Ed25519 del DSS (ottenuta off-line). Servirà a verificare la firma del server.
  \item \textbf{Connessione TCP.} Il client apre una connessione verso il DSS; il server accetta.
  \item \textbf{ClientHello.} Il client genera una chiave \emph{effimera} X25519 per la sessione e un nonce $N_c$, quindi invia al server la propria chiave pubblica effimera e $N_c$.
  \item \textbf{ServerHello con firma.} Il server genera a sua volta una chiave effimera X25519 e un nonce $N_s$, calcola lo \emph{shared secret} ECDH e costruisce il \textbf{transcript} (Tab.~\ref{tab:transcript}). Il server firma l'hash del transcript con la propria chiave privata Ed25519 e invia al client: la sua chiave pubblica effimera, $N_s$ e la \textbf{firma} sul transcript.
  \item \textbf{Verifica autenticità del server (lato client).} Il client ricostruisce lo stesso transcript e ne verifica la firma con la \emph{pubblica} Ed25519 del server. Se la verifica fallisce, la sessione viene interrotta.
  \item \textbf{Derivazione condivisa della chiave di sessione $K$.} Entrambe le parti calcolano lo stesso \emph{shared secret} ECDH. Da questo estraggono e \emph{legano al contesto} la chiave di sessione $K$ tramite \textbf{HKDF-SHA256}, usando i parametri di Tab.~\ref{tab:hkdf}. In questo modo $K$ è univoca per la sessione e vincolata al transcript (protocollo, chiavi effimere, nonces).
  \item \textbf{Key-confirmation bidirezionale.} Client e server si scambiano due brevi messaggi autenticati (\emph{ClientFinish} e \emph{ServerFinish}) cifrati con $K$. Ogni lato verifica di poter decifrare e convalidare il tag di autenticazione, dimostrando di conoscere $K$.
\end{enumerate}

\begin{table}[h]
  \centering
  \caption{Transcript di handshake (bytes in ordine canonico).}
  \label{tab:transcript}
  \begin{tabular}{@{}p{0.27\linewidth}p{0.63\linewidth}@{}}
    \toprule
    \textbf{Campo} & \textbf{Significato} \\
    \midrule
    \texttt{PROTO} & Identificatore protocollo/versione (es.\ \texttt{DSS/1}); previene riusi cross-protocol. \\
    \texttt{client\_pub} & Chiave pubblica \emph{effimera} X25519 del client (PFS). \\
    \texttt{server\_pub} & Chiave pubblica \emph{effimera} X25519 del server (PFS). \\
    \texttt{$N_c$} & Nonce lato client (anti-replay; contribuisce a unicità sessione). \\
    \texttt{$N_s$} & Nonce lato server (anti-replay; contribuisce a unicità sessione). \\
    \bottomrule
  \end{tabular}
\end{table}

\begin{table}[h]
  \centering
  \caption{Parametri di derivazione HKDF per la chiave di sessione $K$.}
  \label{tab:hkdf}
  \begin{tabular}{@{}p{0.27\linewidth}p{0.63\linewidth}@{}}
    \toprule
    \textbf{Parametro} & \textbf{Valore/ruolo} \\
    \midrule
    \texttt{input keying material} & \emph{shared secret} da ECDH X25519. \\
    \texttt{salt} & Concatenazione \texttt{$N_c \Vert N_s$}; garantisce unicità tra sessioni. \\
    \texttt{info} & \texttt{hash(transcript)}; lega $K$ al contesto (protocollo, chiavi, nonces). \\
    \texttt{length} & 32 byte (idoneo ad AES-256-GCM). \\
    \bottomrule
  \end{tabular}
\end{table}

\paragraph{Esito dell'handshake.}
Se le verifiche vanno a buon fine, client e server condividono la stessa chiave $K$ e l'hanno dimostrato (key-confirmation). Il canale sicuro è \emph{attivo}.

\subsection{Fase applicativa: confidenzialità, integrità e anti-replay}
Una volta attivo il canale:
\begin{itemize}
  \item \textbf{Cifratura/autenticazione:} tutti i messaggi applicativi sono protetti con \textbf{AES-GCM} sotto la chiave $K$, ottenendo confidenzialità, integrità e autenticità (tramite il tag AEAD).
  \item \textbf{Anti-replay:} ogni messaggio include un contatore di sequenza \emph{crescente} e un nonce applicativo \emph{unico}; inoltre, una \emph{AAD} (dati autenticati addizionali) lega ogni messaggio al contesto di sessione (tramite l'hash del transcript) e ai parametri anti-replay (seq, nonce).
  \item \textbf{Vincolo richiesta--risposta:} la risposta del server è crittograficamente legata alla richiesta (riutilizzando lo stesso contesto AAD) così da impedire riordinamenti o riusi fuori contesto.
\end{itemize}

\subsection{Mappa concettuale delle operazioni}
\begin{description}
  \item[Autenticazione del server.] Realizzata firmando l'hash del transcript con Ed25519; verificata dal client con la chiave pubblica distribuita off-line.
  \item[PFS (Perfect Forward Secrecy).] Ottenuta grazie alle chiavi X25519 \emph{effimere per sessione} su entrambe le parti.
  \item[Derivazione $K$.] HKDF-SHA256 con \texttt{salt = $N_c\Vert N_s$} e \texttt{info = hash(transcript)} garantisce una chiave unica e contestualizzata.
  \item[Integrità e non-malleabilità.] AES-GCM (AEAD) rifiuta qualsiasi modifica ai messaggi (tag non valido).
  \item[Protezione dal replay.] Combinazione di \emph{seq} crescente, \emph{nonce} unici e AAD che incorpora contesto, seq e nonce.
\end{description}


\subsection{Esempi di uso nella fase applicativa}
Una volta attivo il canale, le operazioni applicative (\texttt{Login}, \texttt{CreateKeys}, \texttt{SignDoc}, \texttt{GetPublicKey}, \texttt{DeleteKeys}) viaggiano all'interno del tunnel cifrato:
\begin{itemize}
  \item \textbf{Richiesta:} il client invia un messaggio cifrato/autenticato con $K$, includendo \emph{seq}, \emph{nonce} e AAD vincolata al transcript.
  \item \textbf{Risposta:} il server elabora, quindi invia la risposta cifrata/autenticata con $K$, riutilizzando lo stesso contesto AAD per legare la risposta alla richiesta.
\end{itemize}
